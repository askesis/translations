#Пакетирование клиентских GraphQL запросов

*Перевод статьи [Batching Client GraphQL Queries
](https://blog.apollographql.com/batching-client-graphql-queries-a685f5bcd41b): [Jake Dawkins](https://twitter.com/JakeDawkins).*

Современные приложения общительны - им требуется много данных, поэтому они выполняют большое количество запросов к различным сервисам для удовлетворения этих потребностей. Покрытие ваших служб GraphQL решает эту проблему, так как он объединяет несколько запросов в одну операцию, избегая лишних обращений к серверу.

В то время как GraphQL поощряет такой метод запроса данных, React рекомендует разработчикам разделить логику запроса данных так, чтобы она была связана с компонентами, которые используют эти данные. Этот шаблон чрезвычайно полезен, но может привести к проблеме, когда приложение делает слишком много сетевых запросов к серверу. Идея пакетирования клиентских операций может быть применена к клиентам GraphQL для решения этой проблемы, но иногда пакетирование может принести больше вреда, чем пользы.

> Пакетировать или не пакетировать - вот в чем вопрос

К концу этого поста вы сможете ответить на следующие вопросы о пакетных операциях клиента с Apollo:

- Как это работает?
- Какие могут возникнуть проблемы?
- Необходимо ли это?
- Можно ли делать это вручную?
- Можно ли улучшить автоматическое пакетирование?

## Как работает батчинг?

Батчинг - это процесс объединения нескольких запросов в один. Обычно это делается с временным порогом. Например, когда запрос сделан из компонента при пороговом значении в 50 мс, вместо немедленного выполнения запроса клиент ожидает 50 мс. Если в эти 50 мс появляются какие-либо другие запросы, все они выполняются одновременно, а не по отдельности.

В GraphQL приложениях батчинг, обычно, бывает двух видов. Первый, когда все операции и объединяются их в одну операцию, используя (функцию псевдонима в GraphQL)[https://graphql.org/learn/queries/#aliases]. Однако такой подход не рекомендуется, поскольку с ним нельзя просто анализировать сетевой траффик по каждой операции и он увеличивает сложность клиента.

Вместо этого мы рекомендуем отправлять массив операций на сервер GraphQL, чтобы сервер обработал каждую операцию отдельно. Этот метод все еще требует только одного приема-передачи, сохраняя при этом возможность отслеживать производительность каждой отдельной операции. Клиент Apollo обрабатывает пакетирование таким образом, используя apollo-link-batch-http. Стоит также отметить, что этот метод требует, чтобы сервер мог получать как массив операций, так и отдельные операции. К счастью, apollo-server поддерживает это "из коробки".

![](https://cdn-images-1.medium.com/max/1600/1*IUrPIx21p74CvO2tTKabkA.png)

Чтобы глубже понять, как пакетная обработка работает с Apollo, ознакомьтесь с этой статьей, в которой рассказывается о пакетной обработке в более ранней версии Apollo Client. Хотя некоторые детали реализации изменились, концепции все еще актуальны сегодня.

## Каковы компромиссы с дозированием?

Пакетная обработка может показаться идеальным решением некоторых проблем производительности сети на клиенте, но это далеко не идеально. Пакетирование запросов склонно к медленному времени загрузки на клиенте. Например, если к конечной точке GraphQL сделано пять запросов от отдельных компонентов, а один из пяти запросов занимает много времени, клиент не получит никаких результатов обратно, пока все операции не будут разрешены. Другими словами, пакетные операции всегда выполняются так же медленно, как и самая медленная операция в пакете.

> Пакетные операции всегда такие медленные, как самая медленная операция в пакете.

Поскольку GraphQL часто используется для агрегирования данных из нескольких источников данных, это может быть проблематично. Если один из базовых сервисов работает медленнее остальных, эффекты могут ощущаться по всему клиентскому приложению.

![](https://cdn-images-1.medium.com/max/1600/1*_1VoQ49cbUEPHL7RPsl0og.gif)

Кроме того, пакетная обработка значительно усложняет отладку сетевого трафика. В большинстве сценариев, если бы для выполнения определенной операции потребовалось много времени, это было бы очевидно. Компонент, выполняющий запрос, застрянет в состоянии загрузки, а остальная часть приложения будет работать нормально. Кроме того, при использовании средств отладки браузера обычно можно легко обнаружить медленные сетевые запросы. Пакетные запросы усложняют оба этих метода отладки.

## Обязательно ли пакетирование?

Прежде чем рассматривать решения проблем, возникающих в процессе пакетной обработки, важно задать вопрос, нужна ли группировка в первую очередь. Поскольку активировать пакетирование так же просто, как заменить одну ссылку apollo другой, заманчиво ввести пакетирование в начале проекта, без каких-либо реальных доказательств необходимости пакетирования. Фактически, из-за его недостатков, мы не рекомендуем пакетировать, если проблемы с производительностью все еще присутствуют после выполнения всех следующих шагов:

- Используйте автоматические постоянные запросы (APQ), чтобы уменьшить размер тела запроса.
- Кэшируйте запросы с помощью CDN, чтобы предотвратить когда-либо операции до конечной точки GraphQL.
- Включите частичное кэширование запросов с Apollo Server, чтобы в большинстве случаев значительно ускорить разрешение операций.
- Если возможно, используйте HTTP / 2 на сервере (с Node.js 10), что позволяет мультиплексировать запросы, эффективно пакетируя их.

## Можно ли пакетировать вручную?

Да! Дозирование может быть сделано вручную. Часто для случаев, когда пакетирование все еще может быть необходимо, недорогие операции могут быть объединены вручную для предотвращения ненужных запросов. В GraphQL это делается путем объединения небольших запросов в один больший. Например, если на странице была страница с четырьмя блоками содержимого, а не для того, чтобы каждый блок извлекал свои собственные данные, контейнер мог бы извлечь данные и передать их компонентам вручную. Это концептуально аналогично первой реализации дозирования, описанной в первом разделе.

Это может показаться нелогичным для установленных шаблонов, таких как сопоставление запросов с компонентами, использующими их ответ, но есть способы обойти это.

Здесь не предлагается писать один большой запрос GraphQL на уровне контейнера. Вместо этого пишите запросы нормально, рядом с компонентами, которые их используют. Когда вы будете готовы оптимизировать раздел приложения, преобразуйте эти запросы во фрагменты и экспортируйте их из файла компонента. Затем вы можете импортировать эти фрагменты в контейнер, позволить контейнеру выполнить один большой запрос и передать результаты фрагмента обратно дочерним элементам. Использование компонентов контейнера таким образом может даже позволить вам контролировать состояния загрузки и ошибок на уровне контейнера, а не в каждом компоненте.

Взгляните на этот CodeSandbox для полного примера этого в действии:

![](https://codesandbox.io/s/wnyxmy8kv7?autoresize=1&fontsize=12&moduleview=1)

Однако даже у ручного дозирования есть проблемы. Поскольку операции, выполняемые вручную, гораздо больше, их способность использовать преимущества кэширования всего запроса снижается. TTL кеша полного запроса основаны на поле в операции с самым коротким TTL. Увеличение количества полей в операции увеличивает вероятность того, что поле, которое не может быть кэшировано в течение длительного времени, включено, уменьшая возможность кэширования всей операции. Подробнее о кэшировании целых запросов и о том, как рассчитываются эти TTL, читайте в этом документе.

## Можно ли исправить автоматическое дозирование?

Там нет серебряной пули для дозирования. Если дозирование включено, всегда есть вероятность того, что части пакета будут работать медленнее и, таким образом, задержат оставшиеся части партии. Однако иногда проблема ручной пакетной обработки перевешивает преимущества. Ручное дозирование может быть слишком сложным или слишком большим для проведения рефакторинга.

Некоторые из проблем, связанных с пакетной обработкой, могут быть решены путем ручной выгрузки дорогостоящих операций, то есть, позволяя пакетировать большинство операций, как обычно, но предотвращая пакетную обработку для тех, которые, как известно, вызывают проблемы. Для этого требуется несколько шагов:

- Сборка компонентов как обычно, с размещением запросов.
- Определите самые дорогие операции с помощью такого инструмента, как Apollo Engine (это не обязательно самые большие запросы).
- Пометить дорогие операции на клиенте, используя контекст операции. Вы можете установить контекст, указав реквизит вашего компонента Query.
- Используйте split для переключения между apollo-link-http или apollo-link-batch-http в зависимости от контекста операции.

Take a look at this CodeSandbox for a full example of this in action:

![](https://codesandbox.io/s/14xk74wk0q?autoresize=1&fontsize=12&moduleview=1)

## Заключение

Дозирование - сложная тема. Существует множество причин для использования той или иной формы пакетирования клиентских запросов, но во многих случаях эти решения вызывают больше проблем, чем решают.

Надеюсь, вооружившись этой информацией, вы сможете чувствовать себя уверенно, принимая решение о том, как повысить производительность на клиенте.

![](https://cdn-images-1.medium.com/max/1600/1*z1jNMuLYJ-eOi_TGIjkjNw.gif)

- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

*Если вам понравилась статья, внизу можно поддержать автора хлопками 👏🏻 Спасибо за прочтение!*
