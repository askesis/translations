#Пакетирование клиентских GraphQL запросов

*Перевод статьи [Batching Client GraphQL Queries
](https://blog.apollographql.com/batching-client-graphql-queries-a685f5bcd41b): [Jake Dawkins](https://twitter.com/JakeDawkins).*

Современные приложения общительны - им требуется много данных, и, таким образом, они выполняют множество запросов к базовым службам для удовлетворения этих потребностей. Распределение GraphQL по вашим сервисам решает эту проблему, так как он объединяет несколько запросов в одну операцию, избегая затрат на несколько циклов.

В то время как GraphQL поддерживает этот стиль извлечения данных, React рекомендует разработчикам разделить логику извлечения данных, чтобы они были связаны с компонентами, которые ее используют. Этот шаблон чрезвычайно полезен, но может привести ко многим из тех же проблем, когда приложение делает слишком много сетевых запросов для сервера для обработки в масштабе. Идея пакетирования клиентских операций может быть применена к клиентам GraphQL для решения многих из этих проблем, но иногда пакетирование может принести больше вреда, чем помощи.

> Пакетировать или не пакетировать - вот в чем вопрос

К концу этого поста вы сможете ответить на следующие вопросы о пакетных операциях клиента с Apollo:

- Как работает пакетирование?
- Каковы компромиссы с дозированием?
- Нужно ли дозировать?
- Можно ли производить дозирование вручную?
- Можно ли исправить автоматическое дозирование?

## Как работает пакетирование?

Пакетная обработка - это процесс сбора группы запросов, их объединения в один и создания одного запроса с теми же данными, что и все остальные запросы. Обычно это делается с временным порогом. Например, при пороговом значении в 50 мс, если запрос сделан из компонента, вместо немедленного выполнения запроса клиент ожидает 50 мс. Если какие-либо другие запросы запрашиваются в эти 50 мс, все эти дополнительные запросы запрашиваются одновременно, а не по отдельности.

В приложениях GraphQL пакетирование обычно принимает одну из двух форм. Первая форма берет все операции и объединяет их в одну операцию, используя функцию псевдонима в GraphQL. Однако такой подход не рекомендуется, поскольку он устраняет простоту отслеживания метрик для каждой операции и добавляет дополнительную сложность клиенту.

Вместо этого мы рекомендуем отправлять массив операций на сервер GraphQL, чтобы сервер распознал запрос как массив операций вместо одной и обрабатывал каждую операцию отдельно. Этот метод все еще требует только одного приема-передачи, сохраняя при этом возможность отслеживать производительность одной операции. Клиент Apollo обрабатывает пакетирование таким образом, используя apollo-link-batch-http. Стоит также отметить, что этот метод требует, чтобы сервер мог получать массив операций, а также отдельные операции. К счастью, apollo-server поддерживает это "из коробки".

![](https://cdn-images-1.medium.com/max/1600/1*IUrPIx21p74CvO2tTKabkA.png)

Чтобы глубже понять, как пакетная обработка работает с Apollo, ознакомьтесь с этой статьей, в которой рассказывается о пакетной обработке в более ранней версии Apollo Client. Хотя некоторые детали реализации изменились, концепции все еще актуальны сегодня.

## Каковы компромиссы с дозированием?

Пакетная обработка может показаться идеальным решением некоторых проблем производительности сети на клиенте, но это далеко не идеально. Пакетирование запросов склонно к медленному времени загрузки на клиенте. Например, если к конечной точке GraphQL сделано пять запросов от отдельных компонентов, а один из пяти запросов занимает много времени, клиент не получит никаких результатов обратно, пока все операции не будут разрешены. Другими словами, пакетные операции всегда выполняются так же медленно, как и самая медленная операция в пакете.

> Пакетные операции всегда такие медленные, как самая медленная операция в пакете.

Поскольку GraphQL часто используется для агрегирования данных из нескольких источников данных, это может быть проблематично. Если один из базовых сервисов работает медленнее остальных, эффекты могут ощущаться по всему клиентскому приложению.

![](https://cdn-images-1.medium.com/max/1600/1*_1VoQ49cbUEPHL7RPsl0og.gif)

Кроме того, пакетная обработка значительно усложняет отладку сетевого трафика. В большинстве сценариев, если бы для выполнения определенной операции потребовалось много времени, это было бы очевидно. Компонент, выполняющий запрос, застрянет в состоянии загрузки, а остальная часть приложения будет работать нормально. Кроме того, при использовании средств отладки браузера обычно можно легко обнаружить медленные сетевые запросы. Пакетные запросы усложняют оба этих метода отладки.

## Обязательно ли пакетирование?

Прежде чем рассматривать решения проблем, возникающих в процессе пакетной обработки, важно задать вопрос, нужна ли группировка в первую очередь. Поскольку активировать пакетирование так же просто, как заменить одну ссылку apollo другой, заманчиво ввести пакетирование в начале проекта, без каких-либо реальных доказательств необходимости пакетирования. Фактически, из-за его недостатков, мы не рекомендуем пакетировать, если проблемы с производительностью все еще присутствуют после выполнения всех следующих шагов:

- Используйте автоматические постоянные запросы (APQ), чтобы уменьшить размер тела запроса.
- Кэшируйте запросы с помощью CDN, чтобы предотвратить когда-либо операции до конечной точки GraphQL.
- Включите частичное кэширование запросов с Apollo Server, чтобы в большинстве случаев значительно ускорить разрешение операций.
- Если возможно, используйте HTTP / 2 на сервере (с Node.js 10), что позволяет мультиплексировать запросы, эффективно пакетируя их.

## Можно ли пакетировать вручную?

Да! Дозирование может быть сделано вручную. Часто для случаев, когда пакетирование все еще может быть необходимо, недорогие операции могут быть объединены вручную для предотвращения ненужных запросов. В GraphQL это делается путем объединения небольших запросов в один больший. Например, если на странице была страница с четырьмя блоками содержимого, а не для того, чтобы каждый блок извлекал свои собственные данные, контейнер мог бы извлечь данные и передать их компонентам вручную. Это концептуально аналогично первой реализации дозирования, описанной в первом разделе.

Это может показаться нелогичным для установленных шаблонов, таких как сопоставление запросов с компонентами, использующими их ответ, но есть способы обойти это.

Здесь не предлагается писать один большой запрос GraphQL на уровне контейнера. Вместо этого пишите запросы нормально, рядом с компонентами, которые их используют. Когда вы будете готовы оптимизировать раздел приложения, преобразуйте эти запросы во фрагменты и экспортируйте их из файла компонента. Затем вы можете импортировать эти фрагменты в контейнер, позволить контейнеру выполнить один большой запрос и передать результаты фрагмента обратно дочерним элементам. Использование компонентов контейнера таким образом может даже позволить вам контролировать состояния загрузки и ошибок на уровне контейнера, а не в каждом компоненте.

Взгляните на этот CodeSandbox для полного примера этого в действии:

![](https://codesandbox.io/s/wnyxmy8kv7?autoresize=1&fontsize=12&moduleview=1)

Однако даже у ручного дозирования есть проблемы. Поскольку операции, выполняемые вручную, гораздо больше, их способность использовать преимущества кэширования всего запроса снижается. TTL кеша полного запроса основаны на поле в операции с самым коротким TTL. Увеличение количества полей в операции увеличивает вероятность того, что поле, которое не может быть кэшировано в течение длительного времени, включено, уменьшая возможность кэширования всей операции. Подробнее о кэшировании целых запросов и о том, как рассчитываются эти TTL, читайте в этом документе.

## Можно ли исправить автоматическое дозирование?

Там нет серебряной пули для дозирования. Если дозирование включено, всегда есть вероятность того, что части пакета будут работать медленнее и, таким образом, задержат оставшиеся части партии. Однако иногда проблема ручной пакетной обработки перевешивает преимущества. Ручное дозирование может быть слишком сложным или слишком большим для проведения рефакторинга.

Некоторые из проблем, связанных с пакетной обработкой, могут быть решены путем ручной выгрузки дорогостоящих операций, то есть, позволяя пакетировать большинство операций, как обычно, но предотвращая пакетную обработку для тех, которые, как известно, вызывают проблемы. Для этого требуется несколько шагов:

- Сборка компонентов как обычно, с размещением запросов.
- Определите самые дорогие операции с помощью такого инструмента, как Apollo Engine (это не обязательно самые большие запросы).
- Пометить дорогие операции на клиенте, используя контекст операции. Вы можете установить контекст, указав реквизит вашего компонента Query.
- Используйте split для переключения между apollo-link-http или apollo-link-batch-http в зависимости от контекста операции.

Take a look at this CodeSandbox for a full example of this in action:

![](https://codesandbox.io/s/14xk74wk0q?autoresize=1&fontsize=12&moduleview=1)

## Заключение

Дозирование - сложная тема. Существует множество причин для использования той или иной формы пакетирования клиентских запросов, но во многих случаях эти решения вызывают больше проблем, чем решают.

Надеюсь, вооружившись этой информацией, вы сможете чувствовать себя уверенно, принимая решение о том, как повысить производительность на клиенте.

![](https://cdn-images-1.medium.com/max/1600/1*z1jNMuLYJ-eOi_TGIjkjNw.gif)

- - - -

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

*Если вам понравилась статья, внизу можно поддержать автора хлопками 👏🏻 Спасибо за прочтение!*
